<!DOCTYPE html>
<html class="home">
<head>
	<meta charset="utf-8">
	<title>STS JS Map</title>

	<style></style>
</head>
<body>

	<svg class="container" width="740" height="940" viewbox="0 0 740 940">
		
	</svg>

	<script>
		'use strict';

		const scale = 50;
		const offset = 20;
		const reverse = true;

		const randomInt = function (min, max) { // includes min and max
			// return Math.floor(Math.random() * (int2 - int1 + 1)) + int1;
			// console.log('random between', min, max);
			min = Math.ceil(min);
			max = Math.floor(max);
			return Math.floor(Math.random() * (max - min + 1)) + min;
		}

		const range = function (start, end) {
			return Array(end - start + 1).fill().map((_, idx) => start + idx);
		}

		const shuffleArray = function (array) {
			for (let i = array.length - 1; i > 0; i--) {
				const j = Math.floor(Math.random() * (i + 1));
				[array[i], array[j]] = [array[j], array[i]];
			}
		}

		const newPoints = function (oldPoint, previousPoint, split=false) {

			console.log('point', previousPoint, oldPoint);

			let limit = (previousPoint) ? previousPoint[previousPoint.length-1] : 0;
			let vals = range(oldPoint-1, oldPoint+1);

			if (limit > 0 && limit >= oldPoint-1) {
				const newRange = [limit, oldPoint+1].sort();
				console.log('potential cross', vals, limit, newRange);
				return newRange;
			}
			/*
			if (limit > 0 && limit >= oldPoint-1) {

				const newRange = range(limit, oldPoint+1);
				console.log('fix potential cross', vals, newRange, limit);
				return newRange;
			}
			*/
			// limit = oldPoint-1;

			// const vals = range(oldPoint-1, oldPoint+1);

			//console.log('point', previousPoint, oldPoint, limit, vals);
			const vals2 = vals.filter(function (e) {
				return (e >= 0 && e < rows);
			});
			
			const howMany = !split ? 1 : randomInt(1, 3);
			// const vals = range(oldPoint-1, oldPoint+1);
			shuffleArray(vals2);

			const newPoints = vals2.slice(0, howMany);
			// console.log('new point can go to', howMany, newPoints);

			/*
			let newPoint = randomInt(oldPoint-1, oldPoint+1);
			// console.log('x',newPoint);
			if (newPoint < 0) { newPoint = 0; }
			if (newPoint > cols-1) { newPoint = cols-1; }
			// console.log(oldPoint, newPoint);

			console.log('z',newPoint);
			*/

			return newPoints.sort();
		}

		const newPoint = function (row, pos, split=false) {

			let lowerLimit = pos-1;
			let upperLimit = pos+1;

// console.log('point', row, pos);
			if (row == 0) {
				// console.log('first row');
			}
			if (pos == 0) {
				// console.log('first item');
				lowerLimit = pos;
			} else {
				const previousPoint = map[row][pos-1];
				if (previousPoint) {
					const newLimit = previousPoint[previousPoint.length-1];
					if (newLimit > lowerLimit) {
						lowerLimit = newLimit;
					}
					//lowerLimit = previousPoint[previousPoint.length-1];
					
					// todo: this happens â€¦ often?!
					// console.log('prev limit', lowerLimit);
				}
			}

			if (pos == cols-1) {
				// console.log('last item');
				upperLimit = cols-1;
			}

			// const howMany = !split ? 1 : randomInt(1, 3);

			let vals = range(lowerLimit, upperLimit);

			const howMany = !split ? 1 : randomInt(1, 3);

			shuffleArray(vals);

			const newPoints = vals.slice(0, howMany);

			// console.log('set range to', newPoints);
			
			return newPoints.sort();
		}

		const makeLine = function (x1, y1, x2, y2) {
			// console.log('drawing line from', x1, y1, x2, y2);

			const ns = 'http://www.w3.org/2000/svg';
			const line = document.createElementNS(ns, 'line');
			// rect.setAttributeNS(null, 'id', 'node-'+randomString());
			line.setAttributeNS(null, 'x1', x1*scale+offset);
			line.setAttributeNS(null, 'y1', y1*scale);
			line.setAttributeNS(null, 'x2', x2*scale+offset);
			line.setAttributeNS(null, 'y2', y2*scale);
			line.setAttributeNS(null, 'data-coords', x1+','+y1+'/'+x2+','+y2);
			line.style.stroke = '#000';
			line.style.strokeWidth = '1px';



			return line;
		}

		const map = [];
		const rows = 12;
		const cols = 7;

		let currentRow = 0;

		while (map.length < rows) {
			// make row of null values
			const row = Array.apply(null, Array(cols)).map(function () {
				return null;
			});

			// add to the map
			map.push(row);

			// const previousRow = map[map.length];

			if (currentRow == 0) {
				// first row

				// make a row of 1 to n
				const vals = Array.apply(null, Array(cols)).map(function (x, i) {
					return i;
				});
				shuffleArray(vals);

				// pick 4 random numbers to start
				const startPoints = vals.slice(0,4).sort();
				for (var i = 0; i < startPoints.length; i++) {
					map[currentRow][startPoints[i]] = newPoint(currentRow, startPoints[i], false);
				}
			} else if (currentRow == 4) {
				// mid row
				const previousRow = map[currentRow-1];
				//map[currentRow][1] = [1];
				//map[currentRow][3] = [3];
				//map[currentRow][5] = [5];

				for (var i = 0; i < cols; i++) {
					if (previousRow[i] == null) continue; // skip null rows

					const x1 = i;
					const y1 = reverse ? rows-currentRow : currentRow-1;

					const targets = previousRow[i];
					for (const target of targets) {
						// make a new point
						// console.log('new midpoint at', [target,currentRow]);
						map[currentRow][target] = [Math.round(target / 2)*2];

						const x2 = target;
						const y2 = reverse ? rows-currentRow-1 : currentRow;
						// console.log('drawing line', i, ' ('+x1+'/'+y1+') to ('+x2+'/'+y2+')');
						const line = makeLine(x1, y1, x2, y2);
						document.querySelector('.container').appendChild(line);
					}
				}
			} else if (currentRow == rows-2) {
				// boss row
				const previousRow = map[currentRow-1];

				for (var i = 0; i < cols; i++) {
					if (previousRow[i] == null) continue; // skip null rows

					const x1 = i;
					const y1 = reverse ? rows-currentRow : currentRow-1;

					const targets = previousRow[i];
					for (const target of targets) {
						// make a new point
						// console.log('new point at', [target,currentRow]);
						map[currentRow][target] = [3];

						const x2 = target;
						const y2 = reverse ? rows-currentRow-1 : currentRow;
						// console.log('drawing line', i, ' ('+x1+'/'+y1+') to ('+x2+'/'+y2+')');
						const line = makeLine(x1, y1, x2, y2);
						document.querySelector('.container').appendChild(line);
					}
				}
			} else {
				// row 2+
				const previousRow = map[currentRow-1];

				for (var i = 0; i < cols; i++) {
					if (previousRow[i] == null) continue; // skip null rows

					const x1 = i;
					const y1 = reverse ? rows-currentRow : currentRow-1;

					const targets = previousRow[i];
					for (const target of targets) {
						// make a new point
						// console.log('new point at', [target,currentRow]);
						map[currentRow][target] = newPoint(currentRow, target, true);

						const x2 = target;
						const y2 = reverse ? rows-currentRow-1 : currentRow;
						// console.log('drawing line', i, ' ('+x1+'/'+y1+') to ('+x2+'/'+y2+')');
						const line = makeLine(x1, y1, x2, y2);
						document.querySelector('.container').appendChild(line);
					}
				}
			}

			
			currentRow += 1;
		}
		console.log(map);

		
	</script>

</body>
</html>
